{"name":"ini","tagline":"Package ini provides INI file read and write functionality in Go.","body":"ini [![Build Status](https://drone.io/github.com/go-ini/ini/status.png)](https://drone.io/github.com/go-ini/ini/latest) [![](http://gocover.io/_badge/github.com/go-ini/ini)](http://gocover.io/github.com/go-ini/ini)\r\n===\r\n\r\n![](https://avatars0.githubusercontent.com/u/10216035?v=3&s=200)\r\n\r\nPackage ini provides INI file read and write functionality in Go.\r\n\r\n## Feature\r\n\r\n- Load multiple data sources(`[]byte` or file) with overwrites.\r\n- Read with recursion values.\r\n- Read with parent-child sections.\r\n- Read with auto-increment key names.\r\n- Read with multiple-line values.\r\n- Read with tons of helper methods.\r\n- Read and convert values to Go types.\r\n- Read and **WRITE** comments of sections and keys.\r\n- Manipulate sections, keys and comments with ease.\r\n- Keep sections and keys in order as you parse and save.\r\n\r\n## Installation\r\n\r\nTo use a tagged revision:\r\n\r\n\tgo get gopkg.in/ini.v1\r\n\r\nTo use with latest changes:\r\n\r\n\tgo get github.com/go-ini/ini\r\n\r\n## Getting Started\r\n\r\n### Loading from data sources\r\n\r\nA **Data Source** is either raw data in type `[]byte` or a file name with type `string` and you can load **as many as** data sources you want. Passing other types will simply return an error.\r\n\r\n```go\r\ncfg, err := ini.Load([]byte(\"raw data\"), \"filename\")\r\n```\r\n\r\nOr start with an empty object:\r\n\r\n```go\r\ncfg := ini.Empty()\r\n```\r\n\r\nWhen you cannot decide how many data sources to load at the beginning, you still able to **Append()** them later.\r\n\r\n```go\r\nerr := cfg.Append(\"other file\", []byte(\"other raw data\"))\r\n```\r\n\r\n### Working with sections\r\n\r\nTo get a section, you would need to:\r\n\r\n```go\r\nsection, err := cfg.GetSection(\"section name\")\r\n```\r\n\r\nFor a shortcut for default section, just give an empty string as name:\r\n\r\n```go\r\nsection, err := cfg.GetSection(\"\")\r\n```\r\n\r\nWhen you're pretty sure the section exists, following code could make your life easier:\r\n\r\n```go\r\nsection := cfg.Section(\"\")\r\n```\r\n\r\nWhat happens when the section somehow does not exist? Don't panic, it automatically creates and returns a new section to you.\r\n\r\nTo create a new section:\r\n\r\n```go\r\nerr := cfg.NewSection(\"new section\")\r\n```\r\n\r\nTo get a list of sections or section names:\r\n\r\n```go\r\nsections := cfg.Sections()\r\nnames := cfg.SectionStrings()\r\n```\r\n\r\n### Working with keys\r\n\r\nTo get a key under a section:\r\n\r\n```go\r\nkey, err := cfg.Section(\"\").GetKey(\"key name\")\r\n```\r\n\r\nSame rule applies to key operations:\r\n\r\n```go\r\nkey := cfg.Section(\"\").Key(\"key name\")\r\n```\r\n\r\nTo check if a key exists:\r\n\r\n```go\r\nyes := cfg.Section(\"\").HasKey(\"key name\")\r\n```\r\n\r\nTo create a new key:\r\n\r\n```go\r\nerr := cfg.Section(\"\").NewKey(\"name\", \"value\")\r\n```\r\n\r\nTo get a list of keys or key names:\r\n\r\n```go\r\nkeys := cfg.Section(\"\").Keys()\r\nnames := cfg.Section(\"\").KeyStrings()\r\n```\r\n\r\nTo get a clone hash of keys and corresponding values:\r\n\r\n```go\r\nhash := cfg.GetSection(\"\").KeysHash()\r\n```\r\n\r\n### Working with values\r\n\r\nTo get a string value:\r\n\r\n```go\r\nval := cfg.Section(\"\").Key(\"key name\").String()\r\n```\r\n\r\nTo validate key value on the fly:\r\n\r\n```go\r\nval := cfg.Section(\"\").Key(\"key name\").Validate(func(in string) string {\r\n\tif len(in) == 0 {\r\n\t\treturn \"default\"\r\n\t}\r\n\treturn in\r\n})\r\n```\r\n\r\nIf you do not want any auto-transformation (such as recursive read) for the values, you can get raw value directly (this way you get much better performance):\r\n\r\n```go\r\nval := cfg.Section(\"\").Key(\"key name\").Value()\r\n```\r\n\r\nTo check if raw value exists:\r\n\r\n```go\r\nyes := cfg.Section(\"\").HasValue(\"test value\")\r\n```\r\n\r\nTo get value with types:\r\n\r\n```go\r\n// For boolean values:\r\n// true when value is: 1, t, T, TRUE, true, True, YES, yes, Yes, y, ON, on, On\r\n// false when value is: 0, f, F, FALSE, false, False, NO, no, No, n, OFF, off, Off\r\nv, err = cfg.Section(\"\").Key(\"BOOL\").Bool()\r\nv, err = cfg.Section(\"\").Key(\"FLOAT64\").Float64()\r\nv, err = cfg.Section(\"\").Key(\"INT\").Int()\r\nv, err = cfg.Section(\"\").Key(\"INT64\").Int64()\r\nv, err = cfg.Section(\"\").Key(\"UINT\").Uint()\r\nv, err = cfg.Section(\"\").Key(\"UINT64\").Uint64()\r\nv, err = cfg.Section(\"\").Key(\"TIME\").TimeFormat(time.RFC3339)\r\nv, err = cfg.Section(\"\").Key(\"TIME\").Time() // RFC3339\r\n\r\nv = cfg.Section(\"\").Key(\"BOOL\").MustBool()\r\nv = cfg.Section(\"\").Key(\"FLOAT64\").MustFloat64()\r\nv = cfg.Section(\"\").Key(\"INT\").MustInt()\r\nv = cfg.Section(\"\").Key(\"INT64\").MustInt64()\r\nv = cfg.Section(\"\").Key(\"UINT\").MustUint()\r\nv = cfg.Section(\"\").Key(\"UINT64\").MustUint64()\r\nv = cfg.Section(\"\").Key(\"TIME\").MustTimeFormat(time.RFC3339)\r\nv = cfg.Section(\"\").Key(\"TIME\").MustTime() // RFC3339\r\n\r\n// Methods start with Must also accept one argument for default value\r\n// when key not found or fail to parse value to given type.\r\n// Except method MustString, which you have to pass a default value.\r\n\r\nv = cfg.Section(\"\").Key(\"String\").MustString(\"default\")\r\nv = cfg.Section(\"\").Key(\"BOOL\").MustBool(true)\r\nv = cfg.Section(\"\").Key(\"FLOAT64\").MustFloat64(1.25)\r\nv = cfg.Section(\"\").Key(\"INT\").MustInt(10)\r\nv = cfg.Section(\"\").Key(\"INT64\").MustInt64(99)\r\nv = cfg.Section(\"\").Key(\"UINT\").MustUint(3)\r\nv = cfg.Section(\"\").Key(\"UINT64\").MustUint64(6)\r\nv = cfg.Section(\"\").Key(\"TIME\").MustTimeFormat(time.RFC3339, time.Now())\r\nv = cfg.Section(\"\").Key(\"TIME\").MustTime(time.Now()) // RFC3339\r\n```\r\n\r\nWhat if my value is three-line long?\r\n\r\n```ini\r\n[advance]\r\nADDRESS = \"\"\"404 road,\r\nNotFound, State, 5000\r\nEarth\"\"\"\r\n```\r\n\r\nNot a problem!\r\n\r\n```go\r\ncfg.Section(\"advance\").Key(\"ADDRESS\").String()\r\n\r\n/* --- start ---\r\n404 road,\r\nNotFound, State, 5000\r\nEarth\r\n------  end  --- */\r\n```\r\n\r\nThat's cool, how about continuation lines?\r\n\r\n```ini\r\n[advance]\r\ntwo_lines = how about \\\r\n\tcontinuation lines?\r\nlots_of_lines = 1 \\\r\n\t2 \\\r\n\t3 \\\r\n\t4\r\n```\r\n\r\nPiece of cake!\r\n\r\n```go\r\ncfg.Section(\"advance\").Key(\"two_lines\").String() // how about continuation lines?\r\ncfg.Section(\"advance\").Key(\"lots_of_lines\").String() // 1 2 3 4\r\n```\r\n\r\nNote that single quotes around values will be stripped:\r\n\r\n```ini\r\nfoo = \"some value\" // foo: some value\r\nbar = 'some value' // bar: some value\r\n```\r\n\r\nThat's all? Hmm, no.\r\n\r\n#### Helper methods of working with values\r\n\r\nTo get value with given candidates:\r\n\r\n```go\r\nv = cfg.Section(\"\").Key(\"STRING\").In(\"default\", []string{\"str\", \"arr\", \"types\"})\r\nv = cfg.Section(\"\").Key(\"FLOAT64\").InFloat64(1.1, []float64{1.25, 2.5, 3.75})\r\nv = cfg.Section(\"\").Key(\"INT\").InInt(5, []int{10, 20, 30})\r\nv = cfg.Section(\"\").Key(\"INT64\").InInt64(10, []int64{10, 20, 30})\r\nv = cfg.Section(\"\").Key(\"UINT\").InUint(4, []int{3, 6, 9})\r\nv = cfg.Section(\"\").Key(\"UINT64\").InUint64(8, []int64{3, 6, 9})\r\nv = cfg.Section(\"\").Key(\"TIME\").InTimeFormat(time.RFC3339, time.Now(), []time.Time{time1, time2, time3})\r\nv = cfg.Section(\"\").Key(\"TIME\").InTime(time.Now(), []time.Time{time1, time2, time3}) // RFC3339\r\n```\r\n\r\nDefault value will be presented if value of key is not in candidates you given, and default value does not need be one of candidates.\r\n\r\nTo validate value in a given range:\r\n\r\n```go\r\nvals = cfg.Section(\"\").Key(\"FLOAT64\").RangeFloat64(0.0, 1.1, 2.2)\r\nvals = cfg.Section(\"\").Key(\"INT\").RangeInt(0, 10, 20)\r\nvals = cfg.Section(\"\").Key(\"INT64\").RangeInt64(0, 10, 20)\r\nvals = cfg.Section(\"\").Key(\"UINT\").RangeUint(0, 3, 9)\r\nvals = cfg.Section(\"\").Key(\"UINT64\").RangeUint64(0, 3, 9)\r\nvals = cfg.Section(\"\").Key(\"TIME\").RangeTimeFormat(time.RFC3339, time.Now(), minTime, maxTime)\r\nvals = cfg.Section(\"\").Key(\"TIME\").RangeTime(time.Now(), minTime, maxTime) // RFC3339\r\n```\r\n\r\nTo auto-split value into slice:\r\n\r\n```go\r\nvals = cfg.Section(\"\").Key(\"STRINGS\").Strings(\",\")\r\nvals = cfg.Section(\"\").Key(\"FLOAT64S\").Float64s(\",\")\r\nvals = cfg.Section(\"\").Key(\"INTS\").Ints(\",\")\r\nvals = cfg.Section(\"\").Key(\"INT64S\").Int64s(\",\")\r\nvals = cfg.Section(\"\").Key(\"UINTS\").Uints(\",\")\r\nvals = cfg.Section(\"\").Key(\"UINT64S\").Uint64s(\",\")\r\nvals = cfg.Section(\"\").Key(\"TIMES\").Times(\",\")\r\n```\r\n\r\n### Save your configuration\r\n\r\nFinally, it's time to save your configuration to somewhere.\r\n\r\nA typical way to save configuration is writing it to a file:\r\n\r\n```go\r\n// ...\r\nerr = cfg.SaveTo(\"my.ini\")\r\nerr = cfg.SaveToIndent(\"my.ini\", \"\\t\")\r\n```\r\n\r\nAnother way to save is writing to a `io.Writer` interface:\r\n\r\n```go\r\n// ...\r\ncfg.WriteTo(writer)\r\ncfg.WriteToIndent(writer, \"\\t\")\r\n```\r\n\r\n## Advanced Usage\r\n\r\n### Recursive Values\r\n\r\nFor all value of keys, there is a special syntax `%(<name>)s`, where `<name>` is the key name in same section or default section, and `%(<name>)s` will be replaced by corresponding value(empty string if key not found). You can use this syntax at most 99 level of recursions.\r\n\r\n```ini\r\nNAME = ini\r\n\r\n[author]\r\nNAME = Unknwon\r\nGITHUB = https://github.com/%(NAME)s\r\n\r\n[package]\r\nFULL_NAME = github.com/go-ini/%(NAME)s\r\n```\r\n\r\n```go\r\ncfg.Section(\"author\").Key(\"GITHUB\").String()\t\t// https://github.com/Unknwon\r\ncfg.Section(\"package\").Key(\"FULL_NAME\").String()\t// github.com/go-ini/ini\r\n```\r\n\r\n### Parent-child Sections\r\n\r\nYou can use `.` in section name to indicate parent-child relationship between two or more sections. If the key not found in the child section, library will try again on its parent section until there is no parent section.\r\n\r\n```ini\r\nNAME = ini\r\nVERSION = v1\r\nIMPORT_PATH = gopkg.in/%(NAME)s.%(VERSION)s\r\n\r\n[package]\r\nCLONE_URL = https://%(IMPORT_PATH)s\r\n\r\n[package.sub]\r\n```\r\n\r\n```go\r\ncfg.Section(\"package.sub\").Key(\"CLONE_URL\").String()\t// https://gopkg.in/ini.v1\r\n```\r\n\r\n### Auto-increment Key Names\r\n\r\nIf key name is `-` in data source, then it would be seen as special syntax for auto-increment key name start from 1, and every section is independent on counter.\r\n\r\n```ini\r\n[features]\r\n-: Support read/write comments of keys and sections\r\n-: Support auto-increment of key names\r\n-: Support load multiple files to overwrite key values\r\n```\r\n\r\n```go\r\ncfg.Section(\"features\").KeyStrings()\t// []{\"#1\", \"#2\", \"#3\"}\r\n```\r\n\r\n### Map To Struct\r\n\r\nWant more objective way to play with INI? Cool.\r\n\r\n```ini\r\nName = Unknwon\r\nage = 21\r\nMale = true\r\nBorn = 1993-01-01T20:17:05Z\r\n\r\n[Note]\r\nContent = Hi is a good man!\r\nCities = HangZhou, Boston\r\n```\r\n\r\n```go\r\ntype Note struct {\r\n\tContent string\r\n\tCities  []string\r\n}\r\n\r\ntype Person struct {\r\n\tName string\r\n\tAge  int `ini:\"age\"`\r\n\tMale bool\r\n\tBorn time.Time\r\n\tNote\r\n\tCreated time.Time `ini:\"-\"`\r\n}\r\n\r\nfunc main() {\r\n\tcfg, err := ini.Load(\"path/to/ini\")\r\n\t// ...\r\n\tp := new(Person)\r\n\terr = cfg.MapTo(p)\r\n\t// ...\r\n\r\n\t// Things can be simpler.\r\n\terr = ini.MapTo(p, \"path/to/ini\")\r\n\t// ...\r\n\r\n\t// Just map a section? Fine.\r\n\tn := new(Note)\r\n\terr = cfg.Section(\"Note\").MapTo(n)\r\n\t// ...\r\n}\r\n```\r\n\r\nCan I have default value for field? Absolutely.\r\n\r\nAssign it before you map to struct. It will keep the value as it is if the key is not presented or got wrong type.\r\n\r\n```go\r\n// ...\r\np := &Person{\r\n\tName: \"Joe\",\r\n}\r\n// ...\r\n```\r\n\r\nIt's really cool, but what's the point if you can't give me my file back from struct?\r\n\r\n### Reflect From Struct\r\n\r\nWhy not?\r\n\r\n```go\r\ntype Embeded struct {\r\n\tDates  []time.Time `delim:\"|\"`\r\n\tPlaces []string\r\n\tNone   []int\r\n}\r\n\r\ntype Author struct {\r\n\tName      string `ini:\"NAME\"`\r\n\tMale      bool\r\n\tAge       int\r\n\tGPA       float64\r\n\tNeverMind string `ini:\"-\"`\r\n\t*Embeded\r\n}\r\n\r\nfunc main() {\r\n\ta := &Author{\"Unknwon\", true, 21, 2.8, \"\",\r\n\t\t&Embeded{\r\n\t\t\t[]time.Time{time.Now(), time.Now()},\r\n\t\t\t[]string{\"HangZhou\", \"Boston\"},\r\n\t\t\t[]int{},\r\n\t\t}}\r\n\tcfg := ini.Empty()\r\n\terr = ini.ReflectFrom(cfg, a)\r\n\t// ...\r\n}\r\n```\r\n\r\nSo, what do I get?\r\n\r\n```ini\r\nNAME = Unknwon\r\nMale = true\r\nAge = 21\r\nGPA = 2.8\r\n\r\n[Embeded]\r\nDates = 2015-08-07T22:14:22+08:00|2015-08-07T22:14:22+08:00\r\nPlaces = HangZhou,Boston\r\nNone =\r\n```\r\n\r\n#### Name Mapper\r\n\r\nTo save your time and make your code cleaner, this library supports [`NameMapper`](https://gowalker.org/gopkg.in/ini.v1#NameMapper) between struct field and actual section and key name.\r\n\r\nThere are 2 built-in name mappers:\r\n\r\n- `AllCapsUnderscore`: it converts to format `ALL_CAPS_UNDERSCORE` then match section or key.\r\n- `TitleUnderscore`: it converts to format `title_underscore` then match section or key.\r\n\r\nTo use them:\r\n\r\n```go\r\ntype Info struct {\r\n\tPackageName string\r\n}\r\n\r\nfunc main() {\r\n\terr = ini.MapToWithMapper(&Info{}, ini.TitleUnderscore, []byte(\"package_name=ini\"))\r\n\t// ...\r\n\r\n\tcfg, err := ini.Load([]byte(\"PACKAGE_NAME=ini\"))\r\n\t// ...\r\n\tinfo := new(Info)\r\n\tcfg.NameMapper = ini.AllCapsUnderscore\r\n\terr = cfg.MapTo(info)\r\n\t// ...\r\n}\r\n```\r\n\r\nSame rules of name mapper apply to `ini.ReflectFromWithMapper` function.\r\n\r\n#### Other Notes On Map/Reflect\r\n\r\nAny embedded struct is treated as a section by default, and there is no automatic parent-child relations in map/reflect feature:\r\n\r\n```go\r\ntype Child struct {\r\n\tAge string\r\n}\r\n\r\ntype Parent struct {\r\n\tName string\r\n\tChild\r\n}\r\n\r\ntype Config struct {\r\n\tCity string\r\n\tParent\r\n}\r\n```\r\n\r\nExample configuration:\r\n\r\n```ini\r\nCity = Boston\r\n\r\n[Parent]\r\nName = Unknwon\r\n\r\n[Child]\r\nAge = 21\r\n```\r\n\r\nWhat if, yes, I'm paranoid, I want embedded struct to be in the same section. Well, all roads lead to Rome.\r\n\r\n```go\r\ntype Child struct {\r\n\tAge string\r\n}\r\n\r\ntype Parent struct {\r\n\tName string\r\n\tChild `ini:\"Parent\"`\r\n}\r\n\r\ntype Config struct {\r\n\tCity string\r\n\tParent\r\n}\r\n```\r\n\r\nExample configuration:\r\n\r\n```ini\r\nCity = Boston\r\n\r\n[Parent]\r\nName = Unknwon\r\nAge = 21\r\n```\r\n\r\n## Getting Help\r\n\r\n- [API Documentation](https://gowalker.org/gopkg.in/ini.v1)\r\n- [File An Issue](https://github.com/go-ini/ini/issues/new)\r\n\r\n## FAQs\r\n\r\n### What does `BlockMode` field do?\r\n\r\nBy default, library lets you read and write values so we need a locker to make sure your data is safe. But in cases that you are very sure about only reading data through the library, you can set `cfg.BlockMode = false` to speed up read operations about **50-70%** faster.\r\n\r\n### Why another INI library?\r\n\r\nMany people are using my another INI library [goconfig](https://github.com/Unknwon/goconfig), so the reason for this one is I would like to make more Go style code. Also when you set `cfg.BlockMode = false`, this one is about **10-30%** faster.\r\n\r\nTo make those changes I have to confirm API broken, so it's safer to keep it in another place and start using `gopkg.in` to version my package at this time.(PS: shorter import path)\r\n\r\n## License\r\n\r\nThis project is under Apache v2 License. See the [LICENSE](LICENSE) file for the full license text.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}